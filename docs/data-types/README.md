# Moveworks Data Types - Complete Documentation

## Overview

Data types specify the structure and kind of values a variable can hold. AI agents are "type-aware" and use data types to determine how to collect them (slots), pass them between plugins, or display them in citations.

**Source**: [Moveworks Data Types Documentation](https://help.moveworks.com/docs/data-types)

## Data Type Categories

### 1. Primitive Data Types

"Simple" values provided by most programming languages:

```yaml
string: text values
integer: whole numbers (1, 2, 100, -5)
number: floating point numbers (1.5, 3.14, -2.7)
boolean: true / false values
```

#### Examples
```yaml
# String type
Data Type: "string"
Example Values: "Hello World", "user@company.com", "BUG-123"

# Integer type  
Data Type: "integer"
Example Values: 1, 42, -10, 0

# Number type
Data Type: "number" 
Example Values: 3.14, -2.5, 0.0, 100.75

# Boolean type
Data Type: "boolean"
Example Values: true, false
```

### 2. Object Data Types

"Complex" values that correspond to data objects from business systems:

#### Built-in Object Types
```yaml
User: A Moveworks user (built-in resolver strategy)
```

#### Custom Object Types
Must follow `u_<DataTypeName>` naming convention:

```yaml
u_SalesforceAccount: An Account object in Salesforce
u_JiraIssue: An Issue object in Jira  
u_FirstnameLastnameFeatureRequest: Custom feature request type
u_ServiceNowIncident: ServiceNow incident object
```

### 3. List/Array Types

Any data type can be configured as a list by prefixing with `List[type]`:

#### Primitive Lists
```yaml
List[string]: array of strings
List[integer]: array of whole numbers
List[number]: array of decimal numbers  
List[boolean]: array of booleans
```

#### Object Lists
```yaml
List[User]: array of User objects
List[u_JiraIssue]: array of Jira issues
List[u_SalesforceAccount]: array of Salesforce accounts
```

## Custom Data Type Creation

### Naming Convention
- **Required Format**: `u_<DataTypeName>`
- **Examples**: `u_JiraIssue`, `u_FeatureRequest`, `u_PurchaseOrder`
- **Invalid**: `JiraIssue`, `jira_issue`, `custom_JiraIssue`

### Schema Definition
Custom data types require JSON schema definitions:

```yaml
# Example: Feature request data type
Name: "u_FirstnameLastnameFeatureRequest"
Description: "Feature request object with status tracking"
Schema:
  type: object
  properties:
    id: 
      type: string
      description: "Unique feature request ID"
    name:
      type: string  
      description: "Feature request title"
    current_status:
      type: string
      enum: ["New", "In Progress", "Done", "Cancelled"]
    created_by:
      type: string
      description: "Email of user who created request"
    moderator:
      type: string
      description: "Email of assigned moderator"
    product_area:
      type: string
      description: "Product area this request affects"
```

### Schema Auto-Generation
Schemas can be auto-generated by importing JSON examples:

```json
{
  "id": "FR-12345",
  "name": "Add Dark Mode",
  "current_status": "New", 
  "created_by": "user@company.com",
  "moderator": "pm@company.com",
  "product_area": "UI/UX"
}
```

## Default Resolver Strategies

Data types can have default resolver strategies to avoid repeating configuration:

```yaml
Data Type: "u_JiraIssue"
Default Resolver Strategy: "JiraIssueResolver"
  Methods:
    - "get_jira_issue_by_id"           # For "update BUG-732"
    - "get_user_assigned_issues"       # For "update my tasks"  
    - "get_issues_by_criteria"         # For "update in-progress tasks"
```

## Important Rules

### 1. System Separation
- **Do not merge data types across systems**
- If you have Accounts in both Salesforce & Netsuite, create separate data types:
  - `u_SalesforceAccount`
  - `u_NetsuiteAccount`

### 2. One System Per Type
- Each data type corresponds to objects from a single business system
- Ensures data consistency and proper resolver strategy mapping

### 3. Naming Consistency
- Custom data types must follow `u_<DataTypeName>` format
- Use PascalCase for the DataTypeName portion
- Be descriptive but concise

## Implementation Status

### âœ… Completed Features
- **All Primitive Types**: string, integer, number, boolean
- **Built-in Object Types**: User type with built-in resolver
- **List Support**: All primitive and object types support List[type] format
- **Custom Data Type Creation**: Full CRUD operations with schema validation
- **u_<DataTypeName> Convention**: Enforced naming validation
- **Schema Import**: Auto-generation from JSON examples
- **Frontend Integration**: Complete UI support for all data types

### âœ… API Endpoints
- `GET /api/agent-studio/data-types` - List all custom data types
- `POST /api/agent-studio/data-types` - Create new custom data type
- `PUT /api/agent-studio/data-types/{id}` - Update custom data type
- `DELETE /api/agent-studio/data-types/{id}` - Delete custom data type
- `POST /api/agent-studio/data-types/import-schema` - Auto-generate schema from JSON

### ðŸ”„ In Progress
- **Default Resolver Strategy Assignment**: Link data types to resolver strategies
- **Runtime Type Validation**: Enforce data type constraints during processing

## Usage Examples

### Slot Configuration with Data Types
```yaml
# String slot
Slot Name: "description"
Data Type: "string"
Description: "Brief description of the issue"

# Integer slot  
Slot Name: "quantity"
Data Type: "integer"
Description: "Number of items to order"

# User slot
Slot Name: "assignee" 
Data Type: "User"
Description: "Person to assign this task to"

# Custom object slot
Slot Name: "jira_issue"
Data Type: "u_JiraIssue" 
Description: "The Jira issue to update"

# List slot
Slot Name: "affected_users"
Data Type: "List[User]"
Description: "Users affected by this incident"
```

## Related Documentation

- [Slots](../slots/README.md) - How slots use data types
- [Resolver Strategies](../resolver-strategies/README.md) - How data types connect to resolvers
- [Custom Data Types API](./api.md) - API reference for data type management
- [Schema Validation](./schema-validation.md) - JSON schema validation rules

## Next Steps

1. **Default Resolver Integration**: Link custom data types to default resolver strategies
2. **Runtime Validation**: Implement data type validation during slot collection
3. **Type Coercion**: Add automatic type conversion (string "123" â†’ integer 123)
4. **Advanced Schema Features**: Support for nested objects and complex validation rules
